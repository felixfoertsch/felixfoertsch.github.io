I"²&<p>This semester I finished my course about automata and languages. I learned a lot and it was really enjoyable. From this field, there was <a href="https://old.reddit.com/r/computerscience/comments/atrs4y/pumping_lemma_in_theory_of_computation/">a question about the Pumping Lemma on the computer science subreddit</a>. So naturally, if someone ask about a thing I know about, Iâ€™ll try to explain it as best as I can â€“ repetition is key for retaining knowledge!</p>

<!-- more -->

<h1 id="my-explanation">My Explanation</h1>

<p><a href="https://old.reddit.com/r/computerscience/comments/atrs4y/pumping_lemma_in_theory_of_computation/eh3aw9k/">My original post on Reddit.</a></p>

<p>To understand the PL, we think about it in two steps. Iâ€™ll do it for the regular languages. You can do the same on your own for the context free languages. The idea is the same.</p>

<ol>
  <li>We create a visual model to understand what it is about.</li>
  <li>We do a PL proof.</li>
</ol>

<h2 id="1-creating-a-visual-model-in-your-mind">1. Creating a visual model in your mind.</h2>

<p>Firstly, we have to keep in mind that we want to show that a language is not regular. Letâ€™s reason a little bit more about regular languages:</p>

<ul>
  <li>Regular languages can be accepted by finite automata (FA). That means: if your language is regular, there is an FA that accepts this language.</li>
  <li>To check, whether a word is accepted by an FA, you start in a state, start reading in letters of your word and follow the edges through the FA. If the whole word is read and we end up in a final state, the FA accepts the word.</li>
  <li>But hold on a second! FA can also accept words that have more letters than we have states and edges. How can that be?! The answer: loops.</li>
  <li>Now, given any regular language, we <strong>know</strong> that there is an FA that accepts it (this is a theorem).</li>
  <li>That means: if we have a word, that has more letters than we have states, but is still accepted by our FA, we <strong>have to have</strong> a loop in our FA.</li>
  <li>Think about it: we can repeat this loop as many times as we want and the FA would still accept words that are processed by going through the loop repeatedly. <strong>It has to!</strong></li>
  <li>This repeating of the loop is referred to as pumping a word up or down.</li>
</ul>

<h2 id="2-doing-a-proof">2. Doing a proof.</h2>
<p>Now, secondly, you want to proof something using this lemma. Letâ€™s start with the PL (really try to understand this line!):</p>

<p><code class="language-plaintext highlighter-rouge">L âˆˆ REG â†’ âˆƒn âˆˆ â„• âˆ€x âˆˆ L: |x| â‰¥ n âˆƒu, v, w: x = u âˆ˜ v âˆ˜ w, |v| â‰¥ 1, |uv| â‰¤ n âˆ€i âˆˆ â„•: u âˆ˜ vâ± âˆ˜ w âˆˆ L</code></p>

<p>Iâ€™ll break it down. Remember: This is a theorem. If you meet the conditions of the implication (part on the left), you now <strong>know</strong> that the part on the right is true.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">L âˆˆ REG â†’</code>: â€œGiven a regular language, the following is true.â€</li>
  <li><code class="language-plaintext highlighter-rouge">âˆƒn âˆˆ â„•</code>: â€œThere is a natural numberâ€</li>
  <li><code class="language-plaintext highlighter-rouge">âˆ€x âˆˆ L: |x| â‰¥ n</code>: â€œFor every word <code class="language-plaintext highlighter-rouge">x</code> that is in the language and longer than this natural numberâ€
    <ul>
      <li>Remember the argument with the loops from part 1. This just says: we now have a word that has more letters than we have states.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">âˆƒu, v, w: x = u âˆ˜ v âˆ˜ w, |v| â‰¥ 1, |uv| â‰¤ n</code>: â€œYou can split up the word <code class="language-plaintext highlighter-rouge">x</code> into three parts: <code class="language-plaintext highlighter-rouge">u, v, w</code> where the length of <code class="language-plaintext highlighter-rouge">v</code> is equal to or bigger than <code class="language-plaintext highlighter-rouge">1</code> and the length of <code class="language-plaintext highlighter-rouge">u âˆ˜ v</code> is smaller than our natural number from beforeâ€
    <ul>
      <li>Here we describe the loop in more detail. <code class="language-plaintext highlighter-rouge">v</code> is the part that we can pump, because there is a loop that processes v (and can thus process arbitrary iterations of v - or skip it altogether. And because <code class="language-plaintext highlighter-rouge">u âˆ˜ v</code> is smaller than <code class="language-plaintext highlighter-rouge">n</code>, we didnâ€™t need a loop until now. We only really <strong>need</strong> a loop, if our word has more letters than we have states!</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">âˆ€i âˆˆ â„•: u âˆ˜ vâ± âˆ˜ w âˆˆ L</code>: â€œIf all the conditions before have been met, we can now pump <code class="language-plaintext highlighter-rouge">v</code> up or down and the resulting word is still in the language!â€
    <ul>
      <li>Since it is a loop, pumping doesnâ€™t make a difference. If you go the loop a million times, the word is still in the language.</li>
    </ul>
  </li>
</ol>

<p>Thatâ€™s it. Again, because it is proved, you <strong>know</strong> itâ€™s true if all the conditions are met.</p>

<p>We want to use the lemma to show, that a language <strong>is not</strong> a regular language. Letâ€™s have a look at the implication from above. Think about the left part of the implication (<code class="language-plaintext highlighter-rouge">L âˆˆ REG</code>) as <code class="language-plaintext highlighter-rouge">A</code> and the right part (<code class="language-plaintext highlighter-rouge">âˆƒn âˆˆ â„• âˆ€x âˆˆ L: |x| â‰¥ n âˆƒu, v, w: x = u âˆ˜ v âˆ˜ w, |v| â‰¥ 1, |uv| â‰¤ n âˆ€i âˆˆ â„•: u âˆ˜ vâ± âˆ˜ w âˆˆ L</code>) as <code class="language-plaintext highlighter-rouge">B</code>: <code class="language-plaintext highlighter-rouge">A â†’ B</code>.</p>

<p>We can now do the following transformation:</p>

<p><code class="language-plaintext highlighter-rouge">A â†’ B â‰¡ Â¬B  â†’ Â¬A</code></p>

<p>To pull in the negation on the right side of this transformation, all the quantifiers have to â€œflip aroundâ€. This means the sentence now looks like this:</p>

<p><code class="language-plaintext highlighter-rouge">âˆ€n âˆˆ â„• âˆƒx âˆˆ L: |x| â‰¥ n âˆ€u, v, w: x = u âˆ˜ v âˆ˜ w, |v| â‰¥ 1, |uv| â‰¤ n âˆƒi âˆˆ â„•: u âˆ˜ vâ± âˆ˜ w âˆ‰ L â†’ L âˆ‰ REG</code></p>

<p>Again, this is still the Pumping Lemma. We didnâ€™t change it, we just used an transformation for the implication that is equivalent. If you meet the conditions on the left, you <strong>know</strong> the sentence on the right is true.</p>

<p>Letâ€™s use this on an example: Show that <code class="language-plaintext highlighter-rouge">L = {aáµ âˆ˜ báµ | k â‰¥ 0}</code> is not regular.</p>

<ol>
  <li>Take any number <code class="language-plaintext highlighter-rouge">n</code>.</li>
  <li>Select a word with the requirement <code class="language-plaintext highlighter-rouge">x âˆˆ L</code> with <code class="language-plaintext highlighter-rouge">|x| â‰¥ n</code>. Your mathematical creativity is requested here! You need to pick a word that helps you show the rest of the conditions easily! We are going to pick: <code class="language-plaintext highlighter-rouge">x = aâ¿bâ¿</code>. This is convenient, because itâ€™s obvious that it is as least as long as n (n occurs twice in it as an exponent). The important property to note: there are exactly as many <code class="language-plaintext highlighter-rouge">a</code> as there are <code class="language-plaintext highlighter-rouge">b</code> in this word. So if we can pump it in a way, that this is not the case anymore, we are golden!</li>
  <li>Now we have to look at <strong>all</strong> of the partitions <code class="language-plaintext highlighter-rouge">x = uvw</code> with the conditions <code class="language-plaintext highlighter-rouge">|v| â‰¥ 1</code> and <code class="language-plaintext highlighter-rouge">|uv| â‰¤ n</code>. Since we have to look at all of them we just say: Letâ€™s assume these conditions are met (we can now use them in the next step).</li>
  <li>Pick an <code class="language-plaintext highlighter-rouge">i</code> that shows that <code class="language-plaintext highlighter-rouge">u âˆ˜ vâ± âˆ˜ w âˆ‰ L</code>. Letâ€™s take <code class="language-plaintext highlighter-rouge">i = 0</code>.
    <ul>
      <li>Since our word is <code class="language-plaintext highlighter-rouge">aâ¿bâ¿</code> and one of the conditions is <code class="language-plaintext highlighter-rouge">|uv| â‰¤ n</code>, we know that <code class="language-plaintext highlighter-rouge">uv</code> can <strong>only</strong> consist of the letter <code class="language-plaintext highlighter-rouge">a</code>.</li>
      <li>And because we have the condition <code class="language-plaintext highlighter-rouge">|v| â‰¥ 1</code>, we also know that <code class="language-plaintext highlighter-rouge">v</code> has to contain <strong>at least</strong> one letter <code class="language-plaintext highlighter-rouge">a</code>.</li>
      <li>If we now remove this letter (or maybe its more than one letter, it doesnâ€™t matter), the amount of letters <code class="language-plaintext highlighter-rouge">a</code> in the word <code class="language-plaintext highlighter-rouge">x</code> is now not equal to the amount of letters <code class="language-plaintext highlighter-rouge">b</code> in the word.</li>
      <li>Hence: Our word is not part of the language any more (<code class="language-plaintext highlighter-rouge">u âˆ˜ vâ° âˆ˜ w âˆ‰ L</code>), violating the PL.</li>
    </ul>
  </li>
</ol>

<p>This shows that <code class="language-plaintext highlighter-rouge">L = {aáµ âˆ˜ báµ | k â‰¥ 0}</code> is not a regular language.</p>
:ET